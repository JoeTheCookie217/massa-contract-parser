{"mappings":"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","sources":["src/index.ts","src/getProbableInterfaces.ts","src/interfaces.ts","src/JsonType.ts","src/methods.ts","src/parseWasm.ts","src/parseContract.ts","src/ParsedContract.ts"],"sourcesContent":["export * from './getProbableInterfaces';\nexport * from './interfaces';\nexport * from './JsonType';\nexport * from './methods';\nexport * from './parseContract';\nexport * from './ParsedContract';\nexport * from './parseWasm';\n","import { StandardInterfaceId, interfaces } from './interfaces';\n\n/**\n * Guesses which standards a contract _probably_ implements based on exported\n * method names.\n *\n * @param methodNames Exported method names\n * @returns Interfaces the contract probably implements, as well as which\n *  methods likely constitute which interfaces\n */\nexport function getProbableInterfaces(methodNames: string[]): {\n  probableInterfaces: StandardInterfaceId[];\n  byMethod: Record<string, StandardInterfaceId[]>;\n} {\n  const probableInterfaces = Object.keys(interfaces).filter(i =>\n    interfaces[i as StandardInterfaceId].methods.every(\n      m => methodNames.indexOf(m.name) !== -1,\n    ),\n  ) as StandardInterfaceId[];\n\n  const byMethod: Record<string, StandardInterfaceId[]> = {};\n  methodNames.forEach(methodName => {\n    byMethod[methodName] = probableInterfaces.filter(\n      i => interfaces[i].methods.map(m => m.name).indexOf(methodName) !== -1,\n    );\n  });\n\n  return { probableInterfaces, byMethod };\n}\n","import { JsonType } from './JsonType';\n\nexport enum StandardInterfaceId {\n  NEP141 = 'nep141',\n  NEP145 = 'nep145',\n  NEP148 = 'nep148',\n  NEP171 = 'nep171',\n  NEP177 = 'nep177',\n  NEP178 = 'nep178',\n  NEP199 = 'nep199',\n  NEP330 = 'nep330',\n}\n\n/**\n * Well-known smart contract interface specification\n */\nexport interface StandardInterface {\n  /** Unique interface ID */\n  id: StandardInterfaceId;\n  /** Human-readable interface name */\n  name: string;\n  /** Methods provided by interface */\n  methods: StandardInterfaceMethod[];\n}\n\nexport interface StandardInterfaceArgument {\n  name: string;\n  /**\n   * An argument can support one or multiple types\n   * (e.g. Rust's `Option<String>` becomes `['string', 'null']`)\n   */\n  type: JsonType | JsonType[];\n}\n\nexport interface StandardInterfaceMethod {\n  name: string;\n  args: StandardInterfaceArgument[];\n}\n\n/**\n * Mapping interface ID to interface specification\n */\nexport const interfaces: Readonly<\n  Record<StandardInterfaceId, StandardInterface>\n> = Object.freeze({\n  [StandardInterfaceId.NEP141]: {\n    id: StandardInterfaceId.NEP141,\n    name: 'FT Core (NEP-141)',\n    methods: [\n      {\n        name: 'ft_transfer',\n        args: [\n          { name: 'receiver_id', type: 'string' },\n          { name: 'amount', type: 'string' },\n          { name: 'memo', type: ['string', 'null'] },\n        ],\n      },\n      {\n        name: 'ft_transfer_call',\n        args: [\n          { name: 'receiver_id', type: 'string' },\n          { name: 'amount', type: 'string' },\n          { name: 'memo', type: ['string', 'null'] },\n          { name: 'msg', type: 'string' },\n        ],\n      },\n      {\n        name: 'ft_total_supply',\n        args: [],\n      },\n      {\n        name: 'ft_balance_of',\n        args: [{ name: 'account_id', type: 'string' }],\n      },\n    ],\n  },\n  [StandardInterfaceId.NEP145]: {\n    id: StandardInterfaceId.NEP145,\n    name: 'Storage Management (NEP-145)',\n    methods: [\n      {\n        name: 'storage_deposit',\n        args: [\n          { name: 'account_id', type: ['string', 'null'] },\n          { name: 'registration_only', type: ['boolean', 'null'] },\n        ],\n      },\n      {\n        name: 'storage_withdraw',\n        args: [{ name: 'amount', type: ['string', 'null'] }],\n      },\n      {\n        name: 'storage_unregister',\n        args: [{ name: 'force', type: ['boolean', 'null'] }],\n      },\n      {\n        name: 'storage_balance_bounds',\n        args: [],\n      },\n      {\n        name: 'storage_balance_of',\n        args: [{ name: 'account_id', type: 'string' }],\n      },\n    ],\n  },\n  [StandardInterfaceId.NEP148]: {\n    id: StandardInterfaceId.NEP148,\n    name: 'FT Metadata (NEP-148)',\n    methods: [\n      {\n        name: 'ft_metadata',\n        args: [],\n      },\n    ],\n  },\n  [StandardInterfaceId.NEP171]: {\n    id: StandardInterfaceId.NEP171,\n    name: 'NFT Core (NEP-171)',\n    methods: [\n      {\n        name: 'nft_transfer',\n        args: [\n          { name: 'receiver_id', type: 'string' },\n          { name: 'token_id', type: 'string' },\n          { name: 'approval_id', type: ['number', 'null'] },\n          { name: 'memo', type: ['string', 'null'] },\n        ],\n      },\n      {\n        name: 'nft_transfer_call',\n        args: [\n          { name: 'receiver_id', type: 'string' },\n          { name: 'token_id', type: 'string' },\n          { name: 'approval_id', type: ['number', 'null'] },\n          { name: 'memo', type: ['string', 'null'] },\n          { name: 'msg', type: 'string' },\n        ],\n      },\n      {\n        name: 'nft_token',\n        args: [{ name: 'token_id', type: 'string' }],\n      },\n    ],\n  },\n  [StandardInterfaceId.NEP177]: {\n    id: StandardInterfaceId.NEP177,\n    name: 'NFT Metadata (NEP-177)',\n    methods: [\n      {\n        name: 'nft_metadata',\n        args: [],\n      },\n    ],\n  },\n  [StandardInterfaceId.NEP178]: {\n    id: StandardInterfaceId.NEP178,\n    name: 'NFT Approval Management (NEP-178)',\n    methods: [\n      {\n        name: 'nft_approve',\n        args: [\n          { name: 'token_id', type: 'string' },\n          { name: 'account_id', type: 'string' },\n          { name: 'msg', type: ['string', 'null'] },\n        ],\n      },\n      {\n        name: 'nft_revoke',\n        args: [\n          { name: 'token_id', type: 'string' },\n          { name: 'account_id', type: 'string' },\n        ],\n      },\n      {\n        name: 'nft_revoke_all',\n        args: [{ name: 'token_id', type: 'string' }],\n      },\n      {\n        name: 'nft_is_approved',\n        args: [\n          { name: 'token_id', type: 'string' },\n          { name: 'approved_account_id', type: 'string' },\n          { name: 'approval_id', type: ['number', 'null'] },\n        ],\n      },\n    ],\n  },\n  [StandardInterfaceId.NEP199]: {\n    id: StandardInterfaceId.NEP199,\n    name: 'Royalties and Payouts (NEP-199)',\n    methods: [\n      {\n        name: 'nft_payout',\n        args: [\n          { name: 'token_id', type: 'string' },\n          { name: 'balance', type: 'string' },\n          { name: 'max_len_payout', type: 'number' },\n        ],\n      },\n      {\n        name: 'nft_transfer_payout',\n        args: [\n          { name: 'receiver_id', type: 'string' },\n          { name: 'token_id', type: 'string' },\n          { name: 'approval_id', type: 'number' },\n          { name: 'balance', type: 'string' },\n          { name: 'max_len_payout', type: 'number' },\n        ],\n      },\n    ],\n  },\n  [StandardInterfaceId.NEP330]: {\n    id: StandardInterfaceId.NEP330,\n    name: 'Source Metadata (NEP-330)',\n    methods: [\n      {\n        name: 'contract_source_metadata',\n        args: [],\n      },\n    ],\n  },\n});\n","/**\n * Data types supported by JSON format\n */\nexport type JsonType =\n  | 'string'\n  | 'number'\n  | 'object'\n  | 'array'\n  | 'boolean'\n  | 'null';\n","import { parseWasm } from './parseWasm';\n\n/**\n * Extracts exported functions from smart contract\n *\n * @param code_base64 Base64-encoded WASM binary (e.g. obtained from\n *  `near-api-js`)\n * @returns List of exported function names\n */\nexport function getMethodNames(code_base64: string): string[] {\n  const ast = parseWasm(code_base64);\n  return ast.body[0].fields\n    .filter(\n      (x: any) => x.type === 'ModuleExport' && x.descr.exportType === 'Func',\n    )\n    .map((x: any) => x.name) as string[];\n}\n","const { decode } = require('@webassemblyjs/wasm-parser');\n\n/**\n * Converts a base64-encoded string to a byte array. Works in browser and Node\n * environments.\n *\n * @param strb64 base64 string\n * @returns Decoded byte array\n */\nfunction base64StringToUint8Array(strb64: string): Uint8Array {\n  if (typeof Buffer !== 'undefined') {\n    // Node\n    return Buffer.from(strb64, 'base64');\n  } else {\n    // Browser\n    return new Uint8Array(\n      atob(strb64.toString().trim())\n        .split('')\n        .map(c => c.charCodeAt(0)),\n    );\n  }\n}\n\n/**\n * Parse base64-encoded WASM into AST\n *\n * @param wasmb64 base64-encoded WASM binary\n * @returns WASM abstract syntax tree\n */\nexport function parseWasm(wasmb64: string): any {\n  return decode(base64StringToUint8Array(wasmb64));\n}\n","import { getProbableInterfaces } from './getProbableInterfaces';\nimport { ParsedContract } from './ParsedContract';\nimport { getMethodNames } from './methods';\n\nexport function parseContract(code_base64: string): ParsedContract {\n  const methodNames = getMethodNames(code_base64);\n  const probableInterfaces = getProbableInterfaces(methodNames);\n  return {\n    methodNames,\n    ...probableInterfaces,\n  };\n}\n","import { StandardInterfaceId } from './interfaces';\n\nexport interface ParsedContract {\n  /**\n   * Standard interfaces the original contract is likely to support\n   */\n  probableInterfaces: StandardInterfaceId[];\n  /**\n   * Maps method names to the ID of the interface they are likey to constitute\n   */\n  byMethod: Record<string, StandardInterfaceId[]>;\n  /**\n   * Names of functions exported from the original contract\n   */\n  methodNames: string[];\n}\n"],"names":[],"version":3,"file":"bundle.js.map"}