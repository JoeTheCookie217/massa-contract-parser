{"mappings":"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","sources":["src/index.ts","src/getProbableInterfaces.ts","src/interfaces.ts","src/JsonType.ts","src/parseContract.ts","src/ParsedContract.ts"],"sourcesContent":["export * from './getProbableInterfaces';\nexport * from './interfaces';\nexport * from './JsonType';\nexport * from './parseContract';\nexport * from './ParsedContract';\n","import { StandardInterfaceId, interfaces } from './interfaces';\n\n/**\n * Guesses which standards a contract _probably_ implements based on exported\n * method names.\n *\n * @param methodNames Exported method names\n * @returns Interfaces the contract probably implements, as well as which\n *  methods likely constitute which interfaces\n */\nexport function getProbableInterfaces(methodNames: string[]): {\n  probableInterfaces: StandardInterfaceId[];\n  byMethod: Record<string, StandardInterfaceId[]>;\n} {\n  const probableInterfaces = Object.keys(interfaces).filter(i =>\n    interfaces[i as StandardInterfaceId].methods.every(\n      m => methodNames.indexOf(m.name) !== -1,\n    ),\n  ) as StandardInterfaceId[];\n\n  const byMethod: Record<string, StandardInterfaceId[]> = {};\n  methodNames.forEach(methodName => {\n    byMethod[methodName] = probableInterfaces.filter(\n      i => interfaces[i].methods.map(m => m.name).indexOf(methodName) !== -1,\n    );\n  });\n\n  return { probableInterfaces, byMethod };\n}\n","import { JsonType } from './JsonType';\n\nexport enum StandardInterfaceId {\n  ERC20 = 'erc20',\n  ERC20Mintable = 'erc20_mintable',\n  ERC20Burnable = 'erc20_burnable',\n}\n\n/**\n * Well-known smart contract interface specification\n */\nexport interface StandardInterface {\n  /** Unique interface ID */\n  id: StandardInterfaceId;\n  /** Human-readable interface name */\n  name: string;\n  /** Methods provided by interface */\n  methods: StandardInterfaceMethod[];\n}\n\nexport interface StandardInterfaceArgument {\n  name: string;\n  /**\n   * An argument can support one or multiple types\n   * (e.g. Rust's `Option<String>` becomes `['string', 'null']`)\n   */\n  type: JsonType | JsonType[];\n}\n\nexport interface StandardInterfaceMethod {\n  name: string;\n  args: StandardInterfaceArgument[];\n}\n\nconst ftCoreMethods: StandardInterfaceMethod[] = [\n  {\n    name: 'version',\n    args: [],\n  },\n  {\n    name: 'name',\n    args: [],\n  },\n  {\n    name: 'symbol',\n    args: [],\n  },\n  {\n    name: 'total_supply',\n    args: [],\n  },\n  {\n    name: 'decimals',\n    args: [],\n  },\n  {\n    name: 'balanceOf',\n    args: [{ name: 'addr', type: 'string' }],\n  },\n  {\n    name: 'transfer',\n    args: [\n      { name: 'to', type: 'string' },\n      { name: 'amount', type: 'number' },\n    ],\n  },\n  {\n    name: 'transferFrom',\n    args: [\n      { name: 'from', type: 'string' },\n      { name: 'to', type: 'string' },\n      { name: 'amount', type: 'number' },\n    ],\n  },\n  {\n    name: 'allowance',\n    args: [\n      { name: 'owner', type: 'string' },\n      { name: 'spender', type: 'string' },\n    ],\n  },\n  {\n    name: 'increaseAllowance',\n    args: [\n      { name: 'spender', type: 'string' },\n      { name: 'amount', type: 'number' },\n    ],\n  },\n  {\n    name: 'decreaseAllowance',\n    args: [\n      { name: 'spender', type: 'string' },\n      { name: 'amount', type: 'number' },\n    ],\n  },\n];\n\n/**\n * Mapping interface ID to interface specification\n */\nexport const interfaces: Readonly<\n  Record<StandardInterfaceId, StandardInterface>\n> = Object.freeze({\n  [StandardInterfaceId.ERC20]: {\n    id: StandardInterfaceId.ERC20,\n    name: 'FT Core (ERC-20)',\n    methods: ftCoreMethods,\n  },\n  [StandardInterfaceId.ERC20Mintable]: {\n    id: StandardInterfaceId.ERC20Mintable,\n    name: 'FT Mint (ERC-20)',\n    methods: [\n      ...ftCoreMethods,\n      {\n        name: 'mint',\n        args: [\n          { name: 'to', type: 'string' },\n          { name: 'amount', type: 'number' },\n        ],\n      },\n    ],\n  },\n  [StandardInterfaceId.ERC20Burnable]: {\n    id: StandardInterfaceId.ERC20Burnable,\n    name: 'FT Burn (ERC-20)',\n    methods: [\n      ...ftCoreMethods,\n      {\n        name: 'burn',\n        args: [{ name: 'amount', type: 'number' }],\n      },\n      {\n        name: 'burnFrom',\n        args: [\n          { name: 'from', type: 'string' },\n          { name: 'amount', type: 'number' },\n        ],\n      },\n    ],\n  },\n});\n","/**\n * Data types supported by JSON format\n */\nexport type JsonType =\n  | 'string'\n  | 'number'\n  | 'object'\n  | 'array'\n  | 'boolean'\n  | 'null';\n","import { getProbableInterfaces } from './getProbableInterfaces';\nimport { ParsedContract } from './ParsedContract';\n\nexport async function parseContract(\n  wasmBase64: string,\n): Promise<ParsedContract> {\n  const bytes = base64StringToUint8Array(wasmBase64);\n  const wasmModule = await WebAssembly.compile(bytes);\n  const methodNames = await exportedFunctionNames(wasmModule);\n  const probableInterfaces = getProbableInterfaces(methodNames);\n\n  return {\n    methodNames,\n    ...probableInterfaces,\n  };\n}\n\n/**\n * Converts a base64-encoded string to a byte array. Works in browser and Node\n * environments.\n *\n * @param strb64 base64 string\n * @returns Decoded byte array\n */\nfunction base64StringToUint8Array(strb64: string): Uint8Array {\n  return new Uint8Array(\n    atob(strb64.toString().trim())\n      .split('')\n      .map(c => c.charCodeAt(0)),\n  );\n}\n\n/**\n * Retrieves the names of all exported functions from a WebAssembly module.\n *\n * @param {WebAssembly.Module} wasmModule - The WebAssembly module to extract the exported function names from.\n * @return {Promise<string[]>} An array of strings containing the names of all exported functions.\n */\nasync function exportedFunctionNames(\n  wasmModule: WebAssembly.Module,\n): Promise<string[]> {\n  const exports = WebAssembly.Module.exports(wasmModule);\n\n  const exportedFunctionNames = exports\n    .filter(e => e.kind === 'function')\n    .map(e => e.name);\n\n  return exportedFunctionNames;\n}\n","import { StandardInterfaceId } from './interfaces';\n\nexport interface ParsedContract {\n  /**\n   * Standard interfaces the original contract is likely to support\n   */\n  probableInterfaces: StandardInterfaceId[];\n  /**\n   * Maps method names to the ID of the interface they are likey to constitute\n   */\n  byMethod: Record<string, StandardInterfaceId[]>;\n  /**\n   * Names of functions exported from the original contract\n   */\n  methodNames: string[];\n}\n"],"names":[],"version":3,"file":"bundle.js.map"}